# Simple Confederated MosaicDB

## The Core Idea

```
BEAM nodes + :pg + content hashing.
That's it.
```

---

## What BEAM Already Gives Us

```elixir
# Connect nodes
Node.connect(:"mosaic@192.168.1.10")

# Send messages anywhere
GenServer.call({Mosaic.QueryEngine, :"mosaic@192.168.1.10"}, {:query, sql})

# Process groups - automatic cluster-wide membership
:pg.join(Mosaic.PG, {:shard, "abc123"}, self())
:pg.get_members(Mosaic.PG, {:shard, "abc123"})  # => PIDs across all nodes

# Process isolation, fault tolerance, hot upgrades
# All free.
```

---

## The Simplest P2P Model

```
┌─────────────┐       ┌─────────────┐       ┌─────────────┐
│   Node A    │◄─────►│   Node B    │◄─────►│   Node C    │
│             │       │             │       │             │
│ :pg groups: │       │ :pg groups: │       │ :pg groups: │
│ shard:1 ●   │       │ shard:2 ●   │       │ shard:1 ●   │
│ shard:2 ●   │       │ shard:4 ●   │       │ shard:5 ●   │
│ shard:3 ●   │       │ shard:5 ●   │       │ shard:6 ●   │
└─────────────┘       └─────────────┘       └─────────────┘

Each node:
- Joins :pg groups for shards it has
- Queries :pg to find who has what
- Fan out queries to relevant nodes
- Automatic cleanup on disconnect
```

---

## Implementation: ~150 Lines

```elixir
defmodule Mosaic.Cluster do
  @moduledoc "Cluster coordination via OTP process groups"
  use GenServer
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def init(_opts) do
    # Start process group scope
    :pg.start(Mosaic.PG)
    
    # Monitor node connections
    :net_kernel.monitor_nodes(true)
    
    # Register local shards
    for shard_id <- Mosaic.ShardStore.local_shards() do
      register_shard(shard_id)
    end
    
    {:ok, %{}}
  end
  
  # === Shard Registry ===
  
  def register_shard(shard_id) do
    :pg.join(Mosaic.PG, {:shard, shard_id}, self())
  end
  
  def unregister_shard(shard_id) do
    :pg.leave(Mosaic.PG, {:shard, shard_id}, self())
  end
  
  def nodes_with_shard(shard_id) do
    :pg.get_members(Mosaic.PG, {:shard, shard_id})
    |> Enum.map(&node/1)
    |> Enum.uniq()
  end
  
  def all_shards do
    :pg.which_groups(Mosaic.PG)
    |> Enum.flat_map(fn
      {:shard, id} -> [id]
      _ -> []
    end)
    |> Enum.uniq()
  end
  
  # === Query Routing ===
  
  def query(sql, params, opts \\ []) do
    # Find relevant shards via bloom filters
    relevant_shards = Mosaic.ShardRouter.find_relevant_shards(sql, params)
    
    # Find nodes that have those shards
    target_nodes = relevant_shards
      |> Enum.flat_map(&nodes_with_shard/1)
      |> Enum.uniq()
    
    # Fan out
    timeout = Keyword.get(opts, :timeout, 5_000)
    
    target_nodes
    |> Task.async_stream(
      fn node -> remote_query(node, sql, params) end,
      timeout: timeout,
      on_timeout: :kill_task
    )
    |> Enum.flat_map(fn
      {:ok, {:ok, rows}} -> rows
      {:ok, {:error, _}} -> []
      {:exit, _} -> []
    end)
  end
  
  defp remote_query(node, sql, params) do
    GenServer.call({Mosaic.QueryEngine, node}, {:local_query, sql, params}, 5_000)
  end
  
  # === Node Events ===
  
  def handle_info({:nodeup, node}, state) do
    IO.puts("Node joined: #{node}")
    {:noreply, state}
  end
  
  def handle_info({:nodedown, node}, state) do
    IO.puts("Node left: #{node}")
    # :pg automatically removes members from disconnected nodes
    {:noreply, state}
  end
end
```

---

## Content Addressing

```elixir
defmodule Mosaic.ContentHash do
  @moduledoc "Shard ID = hash of content. Same content = same ID everywhere."
  
  def shard_id(documents) do
    documents
    |> Enum.sort_by(& &1.id)
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode32(case: :lower, padding: false)
  end
end
```

---

## Replication

```elixir
defmodule Mosaic.Replication do
  @moduledoc "Want a shard? Ask someone who has it."
  
  def replicate(shard_id) do
    case Mosaic.Cluster.nodes_with_shard(shard_id) do
      [] -> 
        {:error, :not_found}
        
      [node | _] ->
        {:ok, data} = GenServer.call({Mosaic.ShardStore, node}, {:get_shard, shard_id})
        Mosaic.ShardStore.save(shard_id, data)
        Mosaic.Cluster.register_shard(shard_id)
        :ok
    end
  end
  
  def maybe_replicate(shard_id) do
    if popular?(shard_id) and not local?(shard_id) do
      replicate(shard_id)
    end
  end
  
  defp popular?(shard_id) do
    # Track query counts, replicate hot shards
    Mosaic.Stats.query_count(shard_id) > 100
  end
  
  defp local?(shard_id) do
    shard_id in Mosaic.ShardStore.local_shards()
  end
end
```

---

## Events (Optional)

```elixir
defmodule Mosaic.Events do
  @moduledoc "Cluster-wide events via Phoenix.PubSub"
  
  def child_spec(_) do
    {Phoenix.PubSub, name: Mosaic.PubSub}
  end
  
  def broadcast(event) do
    Phoenix.PubSub.broadcast(Mosaic.PubSub, "cluster", event)
  end
  
  def subscribe do
    Phoenix.PubSub.subscribe(Mosaic.PubSub, "cluster")
  end
  
  # Usage:
  # Mosaic.Events.broadcast({:document_indexed, doc_id, shard_id})
  # Mosaic.Events.broadcast({:shard_created, shard_id})
end
```

---

## Bootstrap

```elixir
# config/runtime.exs
config :libcluster,
  topologies: [
    # Static list
    static: [
      strategy: Cluster.Strategy.Epmd,
      config: [hosts: [:"mosaic@host1", :"mosaic@host2", :"mosaic@host3"]]
    ]
  ]

# Or for Kubernetes
config :libcluster,
  topologies: [
    k8s: [
      strategy: Cluster.Strategy.Kubernetes.DNS,
      config: [
        service: "mosaic-headless",
        application_name: "mosaic"
      ]
    ]
  ]

# Or for local dev (auto-discover on LAN)
config :libcluster,
  topologies: [
    local: [
      strategy: Cluster.Strategy.Gossip
    ]
  ]
```

---

## Security

```elixir
defmodule Mosaic.Auth do
  @moduledoc "Signed tokens for user auth"
  
  def create_token(user_id, permissions, ttl \\ 3600) do
    payload = %{
      sub: user_id,
      perms: permissions,
      exp: System.system_time(:second) + ttl
    }
    
    signature = :crypto.mac(:hmac, :sha256, secret_key(), :erlang.term_to_binary(payload))
    Base.url_encode64(:erlang.term_to_binary({payload, signature}))
  end
  
  def verify_token(token) do
    {payload, signature} = token |> Base.url_decode64!() |> :erlang.binary_to_term()
    expected = :crypto.mac(:hmac, :sha256, secret_key(), :erlang.term_to_binary(payload))
    
    cond do
      not :crypto.hash_equals(expected, signature) -> {:error, :invalid_signature}
      payload.exp < System.system_time(:second) -> {:error, :expired}
      true -> {:ok, payload}
    end
  end
  
  defp secret_key, do: Application.get_env(:mosaic, :secret_key)
end
```

Node-to-node: Erlang cookie + TLS (built-in).

---

## The Whole Thing

```
┌────────────────────────────────────────────────────────────┐
│                    MosaicDB Node                            │
├────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌───────────────┐    ┌───────────────┐                   │
│   │ :pg Groups    │◄──►│ BEAM          │                   │
│   │ (who has what)│    │ Distribution  │                   │
│   └───────────────┘    └───────────────┘                   │
│          │                                                  │
│          ▼                                                  │
│   ┌───────────────┐    ┌───────────────┐                   │
│   │ Query Router  │───►│ Task.async    │ (fan out)         │
│   │               │◄───│ _stream       │ (fan in)          │
│   └───────────────┘    └───────────────┘                   │
│          │                                                  │
│          ▼                                                  │
│   ┌───────────────┐                                        │
│   │ Local Storage │                                        │
│   │ ┌───────────┐ │                                        │
│   │ │ SQLite    │ │                                        │
│   │ │ + VSS     │ │                                        │
│   │ │ + Spatial │ │                                        │
│   │ └───────────┘ │                                        │
│   │ ┌───────────┐ │                                        │
│   │ │Extensions │ │                                        │
│   │ │AST,GIS,...│ │                                        │
│   │ └───────────┘ │                                        │
│   └───────────────┘                                        │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

---

## Edge Behavior (Emergent)

No special code. It just happens:

```
1. User in Tokyo queries frequently
2. Tokyo node tracks popularity
3. Popular shards auto-replicate to Tokyo
4. Next query is local = fast

5. New node joins in São Paulo  
6. libcluster connects it automatically
7. :pg syncs group membership instantly
8. São Paulo can query the whole cluster
9. Hot data migrates there over time
```

---

## What We Get

| Feature | How |
|---------|-----|
| **No master** | All nodes equal, :pg for coordination |
| **Instant discovery** | :pg syncs membership automatically |
| **Fault tolerant** | Node dies? :pg removes it. Others continue. |
| **Edge caching** | Popular shards replicate to where queries originate |
| **Offline** | Query local shards, reconnect later |
| **Simple** | ~150 lines for cluster layer |
| **Zero config** | libcluster auto-discovers peers |

---

## What We Skip

| Complexity | Why Skip |
|------------|----------|
| Gossip protocol | :pg does it better |
| Kademlia DHT | :pg is enough for <1000 nodes |
| libp2p | BEAM distribution already works |
| CRDTs | Not needed - shards are immutable |
| Consensus | No leader election needed |
| Custom protocols | Use what OTP gives us |

---

## Files to Create

```
lib/mosaic/
├── cluster.ex          # :pg coordination (~50 lines)
├── replication.ex      # Shard copying (~30 lines)
├── content_hash.ex     # Content addressing (~10 lines)
├── auth.ex             # Token auth (~30 lines)
└── events.ex           # PubSub events (~20 lines)
```

---

## Usage

```elixir
# Query across cluster
Mosaic.Cluster.query("SELECT * FROM documents WHERE text LIKE ?", ["%elixir%"])

# Find who has a shard
Mosaic.Cluster.nodes_with_shard("abc123")

# Replicate hot shard locally
Mosaic.Replication.replicate("abc123")

# List all shards in cluster
Mosaic.Cluster.all_shards()
```