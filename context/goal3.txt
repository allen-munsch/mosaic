# MosaicDB: Distributed Semantic Metadata Engine
## Project Plan & Roadmap

---

## Current State (Phase 0 - Complete)

| Component | Status |
|-----------|--------|
| SQLite shards with VSS | ✅ Working |
| Embedding service (local Bumblebee) | ✅ Working |
| Shard routing (centroid + bloom) | ✅ Working |
| Connection pooling | ✅ Working |
| Query caching (Redis) | ✅ Working |
| Federated SQL execution | ✅ Working |
| REST API | ✅ Basic |

---

## Phase 1: Graph Metadata Layer (2-3 weeks)

**Goal:** Transform from document search → semantic graph database

### 1.1 Schema Evolution
```
documents → nodes (entities)
- id, type, properties (JSONB), embedding, created_at

edges (relationships)  
- id, source_id, target_id, type, properties, weight

node_types
- name, schema (JSON Schema for validation)

edge_types
- name, source_type, target_type, schema
```

### 1.2 Graph Query Engine
```elixir
# Traversal queries
Mosaic.Graph.traverse(start_node, depth: 3, edge_types: [:contains, :references])

# Path finding
Mosaic.Graph.shortest_path(from, to, via: [:member_of, :owns])

# Semantic + graph hybrid
Mosaic.Graph.semantic_neighbors("machine learning", hops: 2, min_similarity: 0.7)
```

### 1.3 Deliverables
- [ ] Graph schema migration
- [ ] `Mosaic.Graph` module with traversal primitives
- [ ] Federated graph queries across shards
- [ ] Graph visualization endpoint

---

## Phase 2: RBAC Engine (2-3 weeks)

**Goal:** Semantic role-based access control

### 2.1 RBAC Schema
```
users
- id, name, metadata

roles  
- id, name, permissions (JSONB), rules (semantic rules)

user_roles
- user_id, role_id, scope (optional path/tag restriction)

access_rules
- id, role_id, resource_pattern, conditions, effect (allow/deny)
```

### 2.2 RBAC Evaluator
```elixir
defmodule Mosaic.RBAC do
  # Fast path check
  def can?(user_id, action, resource_path)
  
  # Semantic rule evaluation
  def evaluate_rules(user_id, context)
  
  # List accessible resources
  def accessible_resources(user_id, query)
  
  # Cached policy compilation
  def compile_policy(role_id)
end
```

### 2.3 Semantic Rules
```elixir
# Rules can use semantic similarity
%Rule{
  name: "legal_docs_access",
  condition: "resource.tags SIMILAR TO 'legal, compliance, contracts' WITH similarity > 0.8",
  effect: :allow
}
```

### 2.4 Deliverables
- [ ] RBAC schema and migrations
- [ ] Policy evaluation engine (parallel BEAM processes)
- [ ] Semantic rule parser and executor
- [ ] Policy caching layer
- [ ] Audit logging

---

## Phase 3: Distributed Clustering (2-3 weeks)

**Goal:** Multi-node BEAM cluster with shard distribution

### 3.1 Cluster Topology
```
┌─────────────────────────────────────────────────────────┐
│                    Cluster Ring                          │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐             │
│  │ Node A  │◄──►│ Node B  │◄──►│ Node C  │             │
│  │Shards   │    │Shards   │    │Shards   │             │
│  │0-99     │    │100-199  │    │200-299  │             │
│  └─────────┘    └─────────┘    └─────────┘             │
└─────────────────────────────────────────────────────────┘
```

### 3.2 Components
```elixir
defmodule Mosaic.Cluster do
  # Node management
  def join(node_name)
  def leave(node_name)
  def members()
  
  # Shard placement
  def shards_for_node(node)
  def node_for_shard(shard_id)
  
  # Rebalancing
  def rebalance()
end

defmodule Mosaic.Cluster.HashRing do
  # Consistent hashing for shard placement
  def add_node(ring, node)
  def remove_node(ring, node)
  def get_node(ring, key)
end
```

### 3.3 Distributed Query Coordinator
```elixir
defmodule Mosaic.Distributed.Query do
  # Scatter-gather across nodes
  def execute(sql, params, opts)
  
  # Route to specific node
  def route_to_shard(shard_id, fun)
  
  # Parallel graph traversal
  def distributed_traverse(start, opts)
end
```

### 3.4 Deliverables
- [ ] libcluster integration with custom topology
- [ ] Consistent hash ring for shard placement
- [ ] Distributed query coordinator
- [ ] Node failure detection and recovery
- [ ] Shard replication (configurable factor)
- [ ] Anti-entropy repair process

---

## Phase 4: Object Storage Integration (1-2 weeks)

**Goal:** Separate metadata (MosaicDB) from content (S3/MinIO)

### 4.1 Architecture
```
┌──────────────────┐      ┌──────────────────┐
│   MosaicDB       │      │   Object Store   │
│   (Metadata)     │      │   (Content)      │
│                  │      │                  │
│ - File nodes     │◄────►│ - Blobs          │
│ - Permissions    │      │ - Chunks         │
│ - Embeddings     │      │ - Versions       │
│ - Graph edges    │      │                  │
└──────────────────┘      └──────────────────┘
```

### 4.2 Storage Abstraction
```elixir
defmodule Mosaic.Storage do
  @callback put(key, content, opts) :: {:ok, metadata} | {:error, reason}
  @callback get(key, opts) :: {:ok, content} | {:error, reason}
  @callback delete(key) :: :ok | {:error, reason}
  @callback presigned_url(key, action, ttl) :: {:ok, url}
end

defmodule Mosaic.Storage.S3 do
  @behaviour Mosaic.Storage
  # ExAws implementation
end

defmodule Mosaic.Storage.Local do
  @behaviour Mosaic.Storage
  # Filesystem implementation for dev
end
```

### 4.3 Deliverables
- [ ] Storage behaviour and S3/MinIO adapter
- [ ] Content-addressed storage option
- [ ] Chunked upload/download
- [ ] Presigned URL generation
- [ ] Garbage collection for orphaned blobs

---

## Phase 5: FUSE Virtual Filesystem (3-4 weeks)

**Goal:** Mount MosaicDB as a filesystem

### 5.1 Architecture
```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   FUSE Client   │────►│   gRPC Gateway  │────►│   MosaicDB      │
│   (libfuse)     │     │   (Elixir)      │     │   Cluster       │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                                               │
         │              ┌─────────────────┐              │
         └─────────────►│  Object Store   │◄─────────────┘
                        │  (read blobs)   │
                        └─────────────────┘
```

### 5.2 FUSE Operations Mapping
```elixir
defmodule Mosaic.VFS.Operations do
  # Directory ops → Graph queries
  def readdir(path, user_id) do
    # Find node for path
    # Get children edges
    # Filter by RBAC
    # Return entries
  end
  
  # File ops → Metadata + Object Store
  def read(path, offset, size, user_id)
  def write(path, data, offset, user_id)
  def create(path, mode, user_id)
  def unlink(path, user_id)
  
  # Attribute ops → Node properties
  def getattr(path, user_id)
  def setattr(path, attrs, user_id)
  
  # Extended attributes → Semantic tags
  def getxattr(path, name)
  def setxattr(path, name, value)
end
```

### 5.3 gRPC Service Definition
```protobuf
service MosaicFS {
  rpc Lookup(LookupRequest) returns (LookupResponse);
  rpc ReadDir(ReadDirRequest) returns (stream DirEntry);
  rpc Read(ReadRequest) returns (stream DataChunk);
  rpc Write(stream WriteRequest) returns (WriteResponse);
  rpc GetAttr(GetAttrRequest) returns (Attributes);
  rpc SetAttr(SetAttrRequest) returns (Attributes);
  
  // Semantic extensions
  rpc SemanticSearch(SearchRequest) returns (stream SearchResult);
  rpc SimilarFiles(SimilarRequest) returns (stream FileEntry);
}
```

### 5.4 Special Virtual Directories
```
/mnt/mosaic/
├── by-path/           # Traditional hierarchy
│   └── projects/
│       └── project-a/
├── by-tag/            # Tag-based views
│   ├── legal/
│   └── finance/
├── by-similarity/     # Semantic neighborhoods  
│   └── <file-id>/     # Shows similar files
├── search/            # Query interface
│   └── "machine learning contracts"/
└── recent/            # Time-based views
    ├── today/
    └── this-week/
```

### 5.5 Deliverables
- [ ] gRPC service definition and Elixir server
- [ ] FUSE client (Rust or Go)
- [ ] Path resolution with RBAC integration
- [ ] Read/write with object storage backend
- [ ] Virtual semantic directories
- [ ] Caching layer (directory listings, attrs)
- [ ] Connection multiplexing

---

## Phase 6: Advanced Features (Ongoing)

### 6.1 Real-time Subscriptions
```elixir
defmodule Mosaic.PubSub do
  # Subscribe to changes
  def subscribe(pattern, callback)
  
  # Watch specific paths
  def watch("/projects/*/documents", fn event -> ... end)
  
  # Semantic subscriptions
  def watch_similar(embedding, threshold, callback)
end
```

### 6.2 Version Control
```elixir
defmodule Mosaic.Versions do
  def history(node_id, limit \\ 100)
  def at_time(node_id, timestamp)
  def diff(node_id, v1, v2)
  def restore(node_id, version)
end
```

### 6.3 Full-Text Search Integration
```elixir
# Hybrid search: semantic + keyword
Mosaic.Search.hybrid(
  query: "contract renewal",
  semantic_weight: 0.7,
  keyword_weight: 0.3,
  filters: [type: "document", department: "legal"]
)
```

### 6.4 Analytics & Observability
- Prometheus metrics
- Distributed tracing (OpenTelemetry)
- Query performance analytics
- Access pattern heatmaps

---

## Timeline Overview

```
Month 1          Month 2          Month 3          Month 4
├────────────────┼────────────────┼────────────────┼────────────────┤
│ Phase 1        │ Phase 2        │ Phase 3        │ Phase 5        │
│ Graph Layer    │ RBAC Engine    │ Clustering     │ FUSE VFS       │
│                │                │ + Phase 4      │                │
│                │                │ Object Storage │                │
└────────────────┴────────────────┴────────────────┴────────────────┘
```

---

## Immediate Next Steps

1. **Schema migration** for graph model
2. **Graph traversal module** with federated execution
3. **RBAC prototype** with semantic rules